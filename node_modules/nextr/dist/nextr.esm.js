var isFunction = function isFunction(fn) {
  return typeof fn === 'function';
};

var isCoError = function isCoError(error) {
  return /Co Exception/.test(error.message);
};

var buildCoError = function buildCoError(fn, error) {
  var message = error.message;
  var functionName = fn.name || String(fn).slice(0, 10);
  var coErrorMessage = "[Co Exception " + functionName + "]: " + message;
  error.message = coErrorMessage;
  return error;
};

var Runner = /*#__PURE__*/function () {
  function Runner(_ref) {
    var fn = _ref.fn,
        ancestor = _ref.ancestor,
        onError = _ref.onError,
        onSuccess = _ref.onSuccess,
        onFinish = _ref.onFinish;
    this.prevSibling = null;
    this.nextSibling = null;
    this.fn = fn;
    this.ancestor = ancestor;
    this.onError = onError;
    this.onSuccess = onSuccess;
    this.onFinish = onFinish;
  }

  var _proto = Runner.prototype;

  _proto.run = function run(options) {
    var _this = this;

    var len = this.fn.length;
    var args = options.concat({
      abort: function abort() {
        if (isFunction(_this.onError)) _this.onError();
        if (isFunction(_this.onFinish)) _this.onFinish();
      },
      back: function back() {
        if (_this.prevSibling) _this.prevSibling.run(options);
      },
      resume: function resume() {
        if (_this.prevSibling) _this.prevSibling.upstream(options);
      },
      next: function next() {
        if (_this.nextSibling) {
          _this.nextSibling.run(options);

          return;
        }

        if (isFunction(_this.onSuccess)) _this.onSuccess();
        if (isFunction(_this.onFinish)) _this.onFinish();
      }
    }); // If runner is in the middle, the last one should be `actions`,
    // so args is truncate from end..

    if (this.nextSibling) {
      args = args.slice(-len);
    } else {
      // if len is 1, arg will be context value.
      if (len === 1) args = args.slice(-2, -1);
    }

    try {
      this.fn.apply(this, args);
    } catch (err) {
      // console.log('err ', isCoError(err as Error), err)
      if (isCoError(err)) {
        throw err;
      }

      throw buildCoError(this.fn, err);
    }
  };

  _proto.setPrevSibling = function setPrevSibling(runner) {
    this.prevSibling = runner;
  };

  _proto.setNextSibling = function setNextSibling(runner) {
    this.nextSibling = runner;
  };

  _proto.upstream = function upstream(options) {
    if (this.prevSibling) this.prevSibling.upstream(options);else this.run(options);
  };

  return Runner;
}();

var Co = /*#__PURE__*/function () {
  function Co(options) {
    this.current = null;
    this.ancestor = null;
    this.ctx = options ? options.ctx : {};
  }

  var _proto2 = Co.prototype;

  _proto2.useFn = function useFn(fn, ancestor) {
    var runner = new Runner({
      fn: fn,
      ancestor: ancestor
    });

    if (!this.ancestor) {
      this.ancestor = runner;
    }

    if (this.current) {
      this.current.setNextSibling(runner);
      runner.setPrevSibling(this.current);
    }

    this.current = runner;
  } // private useOne<T1>(
  //   fn: (arg1: T1, ctx: object, actions: actions) => void
  // ): void;
  // private useOne<T1, T2>(
  //   fn: (arg1: T1, arg2: T2, ctx: object, actions: actions) => void
  // ): void;
  // private useOne<T1, T2, T3>(
  //   fn: (arg1: T1, arg2: T2, arg3: T3, ctx: object, actions: actions) => void
  // ): void;
  // private useOne<T1, T2, T3, T4>(
  //   fn: (
  //     arg1: T1,
  //     arg2: T2,
  //     arg3: T3,
  //     arg4: T4,
  //     ctx: object,
  //     actions: actions
  //   ) => void
  // ): void;

  /**
   *
   * @param fn copy middleware function if fn is a co object.
   */
  ;

  _proto2.useOne = function useOne(fn) {
    if (fn instanceof Co) {
      var runner = fn.ancestor;

      while (runner) {
        this.useFn(runner.fn, this.ancestor);
        runner = runner.nextSibling;
      }
    } else if (typeof fn === 'function') {
      this.useFn(fn, this.ancestor);
    }
  }
  /**
   *
   * @param args could be array of function or Co object. When arg is a Co object,
   * its middleware functions will be copied to new Co object.
   */
  ;

  _proto2.use = function use() {
    var _this2 = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    args.forEach(function (fn) {
      return _this2.useOne(fn);
    });
    return this;
  };

  _proto2.start = function start() {
    var contextArg = this.ctx;
    if (typeof contextArg === 'function') contextArg = this.ctx.call(null);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (this.ancestor) this.ancestor.run(args.concat(contextArg));
    return contextArg;
  };

  return Co;
}();

export { Co };
//# sourceMappingURL=nextr.esm.js.map
